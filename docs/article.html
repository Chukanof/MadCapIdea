
<head>
<style type="text/css">
.auto-style1 {
	background-color: #FF0000;
}
</style>
</head>

<h1>Introduction</h1>
<p>This article is the culmination of stuff I have been doing on the train on my 
way to work over 6 months. I have written quite a lot of blog posts on this 
already which you can read about on the projects home page on my blog :
<a href="https://sachabarbs.wordpress.com/2017/05/01/madcap-idea/" target="_blank">
https://sachabarbs.wordpress.com/2017/05/01/madcap-idea/</a> </p>
<p>There are 13 blog posts there, but I thought it would be good to also have 
this overall article which covers all of it, as the blog posts are more a 
sequence of events that I went through which talk about the peices in great 
detail as I went through them</p>
<p>For example these were the blog posts</p>
<ul>
	<li>
	<a href="https://sachabarbs.wordpress.com/2017/05/15/madcap-idea-part-1-start-of-the-client-side-portion-of-the-web-site/" target="_blank">
	MADCAP IDEA PART 1 : START OF THE CLIENT SIDE PORTION OF THE WEB SITE</a></li>
	<li>
	<a href="https://sachabarbs.wordpress.com/2017/05/23/madcap-idea-part-2-adding-diioc-to-the-client-side-front-end-web-site/" target="_blank">
	MADCAP IDEA PART 2 : ADDING DI/IOC TO THE CLIENT SIDE FRONT END WEB SITE</a></li>
	<li>
	<a href="https://sachabarbs.wordpress.com/2017/06/07/madcap-idea-part-3-bringing-play-back-end-into-the-fold-some-basic-streaming-2/" target="_blank">
	MADCAP IDEA PART 3 : BRINGING PLAY BACK END INTO THE FOLD + SOME BASIC 
	STREAMING</a></li>
	<li>
	<a href="https://sachabarbs.wordpress.com/2017/06/07/madcap-idea-part-4-prototyping-the-screens/" target="_blank">
	MADCAP IDEA PART 4 : PROTOTYPING THE SCREENS</a></li>
	<li>
	<a href="https://sachabarbs.wordpress.com/2017/06/13/madcap-idea-part-5-adding-react-router/" target="_blank">
	MADCAP IDEA PART 5 : ADDING REACT-ROUTER</a></li>
	<li>
	<a href="https://sachabarbs.wordpress.com/2017/06/27/madcap-idea-part-6-static-screen-design/" target="_blank">
	MADCAP IDEA PART 6 : STATIC SCREEN DESIGN</a></li>
	<li>
	<a href="https://sachabarbs.wordpress.com/2017/08/01/madcap-idea-part-7-registrationlogin-backend/" target="_blank">
	MADCAP IDEA PART 7 : REGISTRATION/LOGIN BACKEND</a></li>
	<li>
	<a href="https://sachabarbs.wordpress.com/2017/09/01/madcap-idea-part-8-intermediate-step-rest-api-for-interactive-kafka-stream-ktable-queries/" target="_blank">
	MADCAP IDEA PART 8 : INTERMEDIATE STEP, REST API FOR INTERACTIVE KAFKA 
	STREAM KTABLE QUERIES</a></li>
	<li>
	<a href="https://sachabarbs.wordpress.com/2017/09/11/madcap-idea-9-kafka-streams-interactive-queries/" target="_blank">
	MADCAP IDEA PART 9 : KAFKA STREAMS INTERACTIVE QUERIES</a></li>
	<li>
	<a href="https://sachabarbs.wordpress.com/2017/09/21/madcap-idea-10-play-framework-reactive-kafka-producer/" target="_blank">
	MADCAP IDEA PART 10 : PLAY FRAMEWORK REACTIVE KAFKA PRODUCER</a></li>
	<li>
	<a href="https://sachabarbs.wordpress.com/2017/09/28/madcap-idea-11-finishing-the-view-rating-page/" target="_blank">
	MADCAP IDEA PART 11 : FINISHING THE ‘VIEW RATING’ PAGE</a></li>
	<li>
	<a href="https://sachabarbs.wordpress.com/2017/10/24/madcap-idea-12-getting-the-create-job-to-work-end-end/" target="_blank">
	MADCAP IDEA PART 12 : GETTING THE ‘CREATE JOB’ TO WORK END–END</a></li>
	<li>
	<a href="https://sachabarbs.wordpress.com/2017/11/23/madcap-idea-13-getting-the-view-job-to-work-end-end/" target="_blank">
	MADCAP IDEA PART 13 : GETTING THE ‘VIEW JOB’ TO WORK END-END</a></li>
</ul>
<p>&nbsp;</p>
<h2>So just exactly what is it that I was/am talking about?</h2>
<p>In essence I want to write a very (pardon the pun) but uber simple “uber” 
type app. Where there are the following funtional requirements<br><br></p>
<ul>
	<li>There should be a web interface that a client can use. Clients may be a 
	“driver” or a “pickup client” requireing a delivery</li>
	<li>There should be a web interface that a “pickup client” can use, that 
	shows a “pickup client” location on a map, which the “pickup client” choses.</li>
	<li>The “pickup client” may request a pickup job, in which case “drivers” 
	that are in the area bid for a job.</li>
	<li>The “pickup client” location should be visible to a “driver” on a map</li>
	<li>A “driver” may bid for a “pickup client” job, and the bidding 
	“driver(s)” location should be visible to the “pickup client”.</li>
	<li>The acceptance of the bidding “driver” is down to the “pickup client”</li>
	<li>Once a “pickup client” accepts a “driver” ONLY the assigned “driver(s)” 
	current map position will be shown to the “pickup client”</li>
	<li>When a “pickup client” is happy that they have been picked up by a 
	“driver”, the “pickup client” may rate the driver from 1-10, and the 
	“driver” may also rate the “pickup client” from 1-10.</li>
	<li>The rating should only be available once a “pickup client” has marked a 
	job as “completed”</li>
	<li>A “driver” or a “pickup client” should ALWAYS be able to view their 
	previous ratings. </li>
</ul>
<p>Whilst this may sound child’s play to a lot of you (me included if I 
stuck to using simply CRUD operations), I just want to point out that this 
app is meant as a learning experience so I will not be using a simple 
SignalR Hub, and a couple of database tables.</p>
<p>I have written this proj using a completely different set of technologies from the norm. Some 
of the technology choices could easily scale to hundreds of thousands of 
requests per second (Kafka has your back here)<br><br><strong>TECNHOLOGIES 
INVOLVED</strong></p>
<ul>
	<li>WebPack</li>
	<li>React Router</li>
	<li>TypeScript</li>
	<li>Babel.js</li>
	<li>Akka</li>
	<li>Scala</li>
	<li>Play (Scala Http Stack)</li>
	<li>MongoDB</li>
	<li>SBT</li>
	<li>Kafka</li>
	<li>Kafka Streams</li>
</ul>
<p>They say a picture says a 1000nd words, so here is a nice picture to get 
things started</p>
<p><img alt="" height="565" src="overviewSmall.png" width="630"></p>
<p>Now before we carry on, lety me just acknowledge that
<a href="http://www.codeproject.com">www.codeproject.com</a> is mainly a 
Microsoft set of articles, and this code is mainly scala/typescript I think 
there is still plenty to learn along the way, so dont let the fact its not 
.NET/C/C++ put you off</p>
<p>&nbsp;</p>
<h1>Where is the code?</h1>
<p>The code for all of this lot is here :
<a href="https://github.com/sachabarber/MadCapIdea" target="_blank">
https://github.com/sachabarber/MadCapIdea</a></p>
<h1>Demo Video</h1>
<p class="auto-style1">NEED TO DO THIS</p>
<h1>Prerequisites</h1>
<p>As shown in the introduction section, there are many moving peices to this 
demo, so there are quite naturally a few dependencies. I did try to get it to 
work in Docker for you all, however I found that I still needed to create 
external scripts to orchestrate it all anyway. In the end I just went with 
downloading stuff as I will specify, and then giving a single PowerShell script 
to run most stuff, apart from 2 Scala projects.</p>
<p>This is the list of stuff you will need in order to run this code:</p>
<p>This has all been developed on Windows, so these instructions are all about 
how to get stuff working on Windows<br><br>- MongoDB :
<a href="https://www.mongodb.com/dr/fastdl.mongodb.org/win32/mongodb-win32-x86_64-2008plus-ssl-3.4.6-signed.msi/download" target="_blank">
https://www.mongodb.com/dr/fastdl.mongodb.org/win32/mongodb-win32-x86_64-2008plus-ssl-3.4.6-signed.msi/download</a><br>
- Confluence Platform 3.3.0 Open Source :
<a href="http://packages.confluent.io/archive/3.3/confluent-oss-3.3.0-2.11.zip" target="_blank">
http://packages.confluent.io/archive/3.3/confluent-oss-3.3.0-2.11.zip</a><br>- 
SBT<br>- Java 8 SDK<br>- Webpack<br>- Node.Js<br>- NPM<br>- IntelliJ IDEA v17.0 
community<br>- PowerShell</p>
<p>Once you have downloaded all of this you will need to do a few things in 
order to run it nicely on Windows, so these instructions are all about how to 
get stuff working on Windows<br><br>- Download the dependencies above <span style="background-color:yellow; border:1px black solid">(Keep a 
note of where you downloaded them as you will need them here and later)</span><br>- 
Replace the official <span style="background-color:yellow; border:1px black solid">YOUR extract location</span>\confluent-3.3.0\bin\windows BAT files with the ones found 
here :
<a href="https://github.com/renukaradhya/confluentplatform/tree/master/bin/windows" target="_blank">
https://github.com/renukaradhya/confluentplatform/tree/master/bin/windows</a><br>
- Modify the <span style="background-color:yellow; border:1px black solid">YOUR extract location</span>\confluent-3.3.0\etc\kafka\zookeeper.properties file to change the 
<code>dataDir </code>to something like <code>dataDir=c:/temp/zookeeper</code><br>- Modify the 
<span style="background-color:yellow; border:1px black solid">YOUR extract location</span>\confluent-3.3.0\etc\kafka\server.properties file to uncomment the line 
<code>delete.topic.enable=true</code><br>- Modify the 
<span style="background-color:yellow; border:1px black solid">YOUR extract location</span>\confluent-3.3.0\etc\kafka\server.properties file file to change the 
<code>log.dirs</code> to <code>log.dirs=c:/temp/kafka-logs</code></p>
<p>You will need to remember some of these paths for the next section too, so 
just be mindful that you may have to edit the PowerShell script later with some 
new paths</p>
<h1>How do I run all this stuff?</h1>
<p>There are quite a few moving peices to this app, and they all need to be 
running in order for it to all work together.</p>


<strong>1. Update node.js dependencies</strong>
<p>Make sure you have Node.Js installed, and make sure NPM is installed too, also ensure that webpack is globally installed</p>
<p>Open command line and change to the <code>MadCapIdea\PlayBackEndApi\FrontEndWebSite\</code> folder and run 
<code>npm install</code></p>
<ul>
<li>now run <code>webpack </code>from same folder</li>
</ul>

<strong>2. Kafka/Zookeeper etc etc</strong>
<p>You can run the following powershell script to get all the pre-requistites up and running (assuming you have downloaded them all)
</p>
<ul>
<li>Open PowerShell command line and change to the <code>PowerShellProject\PowerShellProject\</code> folder and run 
<code>.\RunPipeline.ps1</code></li>
</ul>

<strong>3. Play application</strong>
<ul>
<li>Open the SBT/Scala project inside IntelliJ IDEA (you will need the SBT plugin, and Java8 installed on your machine).</li>
<li>Open this folder <code>MadCapIdea\PlayBackEndApi </code>and run it.You may need to create a run time configuration</li>
</ul>


<strong>4. Kafka Streams application</strong>
<ul>
<li>Open the SBT/Scala project inside IntelliJ IDEA (you will need the SBT plugin, and Java8 installed on your machine). </li>
<li>Open this folder <code>MadCapIdea\KafkaStreams</code> and run it.You may need to create a run time configuration 
where you point to this main class <code>RatingStreamProcessingApp</code></li>
</ul>

<strong>5. React</strong>
<ul>
<li>Open a browser navigate to <code>http://localhost:9000</code>, and register some users both passenger/driver</li>
</ul>



<p>I normally follow this set of steps afterwards</p>
<ul>
<li>open a tab, login as a passenger that I had created</li>
<li>go to the "create job" page, click the map, push the "create job" button</li>
<li>open a NEW tab, login as a new driver, go to the "view job" page</li>
<li>on the 1st tab (passenger) click the map to push passenger position to driver</li>
<li>on the 2nd tab (driver) click the map to push driver position to passenger</li>
<li>repeat last 4 steps for additonal driver</li>
<li>on client tab pick driver to accept, click accept button</li>
<li>complete the job from client tab, give driver rating</li>
<li>complete the job from paired driver tab, give passenger rating</li>
<li>go to "view rating" page, should see ratings</li>

</ul>








<h1>&nbsp;</h1>
<h1>Known issues</h1>
<p>The following are known issues</p>
<ul>
	<li>Once a driver and passenger become paired, the position updates from 
	either are no longer reflected. I am sure this would boil down to a single 
	JavaScript method that needs updating in the <code>ViewJob.tsx</code> file. However I 
	just kind of got to the end of a very long road (I have been writing about 
	this on an off for 6 months of train rides) and was just happy that I got 
	99% of the stuff done, and just thought you know what, the app as it is now 
	demonstrates everything I set out to do, so I&#39;m ok with one known issue. 
	Sue me</li>
</ul>
<h1>Some basics</h1>
<p>Before we dive into the actual code for the app (and there is quite a bit of 
it), I just thought it may be good to go over some of the individual building 
blocks that make up the app as a whole first, the next few sections will do 
that.It is a long list of stuff, and the demo app makes use of all of this plus 
a few more bits, that I deemed to be not important enough to warrant their own 
sections. We will learn more about each of these when we walk through the actual 
demo app code, this is more of an overiew of the various parts before we look at 
the specific usage</p>
<h2>What is Kafka?</h2>
<p><strong>Overview</strong></p>
<p><em>Apache Kafka is an open-source stream processing platform developed by 
the Apache Software Foundation written in Scala and Java. The project aims to 
provide a unified, high-throughput, low-latency platform for handling real-time 
data feeds. Its storage layer is essentially a &quot;massively scalable pub/sub 
message queue architected as a distributed transaction log,&quot; making it highly 
valuable for enterprise infrastructures to process streaming data. Additionally, 
Kafka connects to external systems (for data import/export) via Kafka Connect 
and provides Kafka Streams, a Java stream processing library.<br><br>The design 
is heavily influenced by transaction logs.</em></p>
<p><strong>Apache Kafka Architecture</strong></p>
<p><em>Kafka stores messages which come from arbitrarily many processes called 
&quot;producers&quot;. The data can thereby be partitioned in different &quot;partitions&quot; 
within different &quot;topics&quot;. Within a partition the messages are indexed and 
stored together with a timestamp. Other processes called &quot;consumers&quot; can query 
messages from partitions. Kafka runs on a cluster of one or more servers and the 
partitions can be distributed across cluster nodes.</em></p>
<p><em>Apache Kafka efficiently processes the real-time and streaming data when 
used along with Apache Storm, Apache HBase and Apache Spark. Deployed as a 
cluster on multiple servers, Kafka handles its entire publish and subscribe 
messaging system with the help of four APIs, namely, producer API, consumer API, 
streams API and connector API. Its ability to deliver massive streams of message 
in a fault-tolerant fashion has made it replace some of the conventional 
messaging systems like JMS, AMQP, etc.</em></p>
<p><em>The major terms of Kafka&#39;s architecture are topics, records, and brokers. 
Topics consist of stream of records holding different information. On the other 
hand, Brokers are responsible for replicating the messages. There are four major 
APIs in Kafka:The major terms of Kafka&#39;s architecture are topics, records, and 
brokers. Topics consist of stream of records holding different information. On 
the other hand, Brokers are responsible for replicating the messages. There are 
four major APIs in Kafka:</em></p>
<ul>
	<li><em>Producer API - Permits the applications to publish streams of 
	records. </em><strong>(covered in this article)</strong></li>
	<li><em>Consumer API - Permits the application to subscribe to the topics 
	and processes the stream of records. </em><strong>(covered in this article)</strong></li>
	<li><em>Streams API – This API converts the input streams to output and 
	produces the result. </em><strong>(covered in this article)</strong></li>
	<li><em>Connector API – Executes the reusable producer and consumer APIs 
	that can link the topics to the existing applications. </em><strong>(not 
	covered in this article)</strong></li>
</ul>
<p><img alt="" height="298" src="kafka1.png" width="400"></p>
<p>&nbsp;</p>
<p><strong>Anatomy of a Kafka Topic</strong></p>
<p><strong>Offset</strong> : messages in the partitions are each assigned a 
unique (per partition) and sequential Id, called the &quot;offset&quot;. The &quot;offset&quot; is 
tracked by consumers, where each consumer tracks via (offset, partition, topic) 
tuples</p>
<p><img alt="" height="245" src="kafka2.png" width="462"></p>
<p><strong>Consumer Groups</strong></p>
<p>Consumers label themselves with a consumer group name, and each record 
published to a topic is delivered to one consumer instance within each 
subscribing consumer group. Consumer instances can be in separate processes or 
on separate machines.<br><br>
<img alt="" height="376" src="kafka3.png" width="630"></p>
<p>If all the consumer instances have the same consumer group, then the records 
will effectively be load balanced over the consumer instances.<br><br>If all the 
consumer instances have different consumer groups, then each record will be 
broadcast to all the consumer processes</p>
<p><img alt="" height="252" src="kafka4.png" width="474"></p>
<p>A two server Kafka cluster hosting four partitions (P0-P3) with two consumer 
groups. Consumer group A has two consumer instances and group B has four.</p>
<p>&nbsp;</p>
<p><strong>Kafka Performance</strong></p>
<p><em>Due to its widespread integration into enterprise-level infrastructures, 
monitoring Kafka performance at scale has become an increasingly important 
issue. Monitoring end-to-end performance requires tracking metrics from brokers, 
consumer, and producers, in addition to monitoring ZooKeeper which is used by 
Kafka for coordination among consumers</em></p>
<p><a href="https://en.wikipedia.org/wiki/Apache_Kafka">
https://en.wikipedia.org/wiki/Apache_Kafka</a> up on date 02/01/18</p>
<p>&nbsp;</p>
<h2>What is Kafka Streams?</h2>
<p><em>The Streams API of Apache Kafka, available through a Java library, can be 
used to build highly scalable, elastic, fault-tolerant, distributed applications 
and microservices. First and foremost, the Kafka Streams API allows you to 
create real-time applications that power your core business. It is the easiest 
yet the most powerful technology to process data stored in Kafka. It builds upon 
important concepts for stream processing such as efficient management of 
application state, fast and efficient aggregations and joins, properly 
distinguishing between event-time and processing-time, and seamless handling of 
late-arriving and out-of-order data.</em></p>
<p><em>A unique feature of the Kafka Streams API is that the applications you 
build with it are normal Java applications. These applications can be packaged, 
deployed, and monitored like any other Java application – there is no need to 
install separate processing clusters or similar special-purpose and expensive 
infrastructure!</em></p>
<p><img alt="" height="433" src="kafkastream1.png" width="630"><em><br></em><br>
<em>An application that uses the Kafka Streams API is a normal Java application. 
Package, deploy, and monitor it like you would do for any other Java 
application. Even so, your application will be highly scalable, elastic, and 
fault-tolerant.</em></p>
<p><a href="https://docs.confluent.io/current/streams/introduction.html">
https://docs.confluent.io/current/streams/introduction.html</a> up on date 
02/01/18</p>
<p>So that is what the official docs say about it,. here is my take on it</p>
<p>Kafka Streams is an additional API on top of Kafka that allows you to perform 
many aggregate and filtering, time based windowing operations over the incoming 
messages, that can either be stored to an internal database key-value 
representation known as a KTable which uses a state store (based on
<a href="http://rocksdb.org/" target="_blank">RocksDB</a>). Or you may choose to 
push the transformed stream values out to a new output topic. </p>
<p>You can perform complex stream processing, merge streams, and also store 
accumulated stream state.</p>
<p>It is a an <strong>AWESOME</strong> bit of kit</p>
<h2>What is Play?</h2>
<p>The Play Framework is a Scala based MVC (model view controller) type web 
application framework. As such it has in built mechanisms for things typical of 
a MVC web framework (certainly if you have done any ASP MVC . NET you would find 
it very familiar).</p>
<p>So we have the typical MVC concerns covered by the
<a href="https://www.playframework.com/documentation/2.5.x/Home" target="_blank">
Play Framework</a></p>
<ul>
	<li>Controllers</li>
	<li>Actions</li>
	<li>Routing</li>
	<li>Model binding</li>
	<li>JSON support</li>
	<li>View engine</li>
</ul>
<p>Thing is I will not be doing any actual HTML in the <a href="https://www.playframework.com/documentation/2.5.x/Home" target="_blank">
Play Framework</a> back end code, I want to do all of that using the previously covered webpack/typescript/react starter code I have shown so far. Rather I will be using the Play Framework as a API backend, where we will simply be using various controllers as endpoint to accept/serve JSON, and Event streamed data. All the actual front end work/routing will be done via webpack and React.
</p>
<p>There are still some very appealing parts in Play that I did want to make use of, such as:</p>
<ul>
<li>It is Scala, which means when I come to integrate Kafka / Kafka Streams it will be ready to do so</li>
<li>It uses Akka which I wanted to use. I also want to use Akka streams, which Play also supports</li>
<li>Play controllers lend themselves quite nicely to being able to create a fairly simple REST API</li>
<li>It can be used fairly easily to serve static files (think of these as the final artifacts that come out of the webpack generation pipeline). So things like minimized CSS / JS etc etc</li>
</ul>
<p>So hopefully you can see that using Play Framework still made a lot of sense, even if we will only end up using 1/2 of what it has to offer. To be honest the idea of using controllers for a REST API is something that is done in ASP MVC .NET all time either by using of actual controllers or by using the WebApi.</p>
<p>Ok so now that we know what we will be using Play Framework for, how about we dive into the code for this post.</p>
<p><strong>Play Framework Basics</strong></p>
<p>Lets start by looking at the bare bones structure of a Play Framework application, which looks like this (I am using IntelliJ IDEA as my IDE)</p>



<p><img alt="" height="377" src="play1.png" width="400"></p>
<p>Lets talk a bit about each of these folders</p>
<p><strong>app</strong></p>
<p>This folder would hold controllers/views (I have added the Entities folder there that is not part of a Play Framework application requirements). Inside the controllers folder you would find controllers, and inside the views folder you would find views. For the final app there will be no views folder, I simply kept that in this screenshot to talk about what a standard Play Framework application looks like</p>

<p><strong>conf</strong></p>
<p>This folder contains the configuration for the Play Framework application. This would include the special routes file, and any other application specific configuration would might have.</p>
<p>Lets just spend a minute having a look at the Play Framework routes file, which you can read more about here : https://www.playframework.com/documentation/2.5.x/ScalaRouting</p>
<p>The routes file has its own DSL, that is responsible for matching a give route with a controller + controller action. The controller action that matches the route is ultimately responsible for servicing the http request. I think the DSL shown in routes file below is pretty self explanatory with perhaps the exception of the assets based routes.</p>
<p>All assets based http requests (ie ones that start with /assets for example http://localhost:9000/assets/images/favicon.png would actually be routed through to a special controller called Assets. You dont see any code for this one, its part of the Play Framework application codebase. This special Assets inbuilt play controller is responsible for serving up static data files which it expects to find in the public folder. So for example our initial request of http://localhost:9000/assets/images/favicon.png would get translated into this file (relative path from project root) /public/images/favicon.png. As I say this is handled for you by the special Assets built in controller.</p>
<p>The only other funky part to the Assets based route is that it uses a *file in its route. Which essentially boils down to the play framework being able match a multi-part path. Which we actually just saw with the example above http://localhost:9000/assets/images/favicon.png , see how that contains not only the file name, but also a directory of images. The Assets controller + routing is able to deal with that path just fine.</p>
<pre>
# Routes
# This file defines all application routes (Higher priority routes first)
# ~~~~

# Home page

GET        /                                   controllers.HomeController.index()

GET        /scala/comet/liveClock              controllers.ScalaCometController.streamClock()
GET        /scala/comet/kick                   controllers.ScalaCometController.kickRandomTime()

# Map static resources from the /public folder to the /assets URL path
GET        /assets/*file                       controllers.Assets.at(path="/public", file)
</pre>
<p>Ok so moving on to the rest of the standard folders that come with a Play Framework application</p>
<p><strong>public</strong></p>
<p>This is where you will need to put any static content that you wish to be served. Obviously views (if you use that part of play) will be within in the app/views folder. Like I say I am not using the views aspect of Play so you will not be seeing any views in my views folder. I instead want to let webpack et all generate my routing, web page etc etc. I do however want to serve bundles so later on I will be showing you how my webpack generated bundles fit in with the Play Framework ecco system.</p>
<p><strong>target</strong></p>
<p>Since this is a scala based project we get the standard scala based folders, and target is one of them, that has the generated/compiled code in it.</p>
<p><strong>SBT</strong></p>
<p>It is worth pointing out that my Play Framework application is an SBT based project, as such there is an SBT aspect to it, which largely boils down to these files</p>
<p><strong>Project [root-build] / plugs.sbt file</strong></p>
<p>This file adds Play as a plugin for the SBT project</p>
<pre>
// The Lightbend repository
resolvers += Resolver.typesafeRepo("releases")

// Use the Play sbt plugin for Play projects
addSbtPlugin("com.typesafe.play" % "sbt-plugin" % "2.5.14")
</pre>
<p><strong>build.sbt</strong></p>
<p>This is the main SBT build file for the project. This is where all our external dependencies are brought in etc etc (standard SBT stuff)</p>
<pre>
import play.sbt._
import sbt.Keys._
import sbt._

name := "play-streaming-scala"

version := "1.0-SNAPSHOT"

scalaVersion := "2.11.11"

lazy val root = (project in file(".")).enablePlugins(play.sbt.PlayScala)

javacOptions ++= Seq("-source", "1.8", "-target", "1.8", "-Xlint")

initialize := {
  val _ = initialize.value
  if (sys.props("java.specification.version") != "1.8")
    sys.error("Java 8 is required for this project.")
}
</pre>
<p>So I think that covers the basics of a standard Play Framework application, the remainder of this article will cover the actual code for the demo project, where we will dive into routes/controllers etc etc</p>




<h2>What is Akka</h2>
<p><a href="https://akka.io/" target="_blank">Akka</a> is a great framework for 
building distibuted fault tolerant apps. It is built around the concept of 
actors, and has failure in mnid from the outset. It also comes with suport for 
HTTP over actors, and comes with play suport out of the box. One thing that also 
comes with Akka that I make use of is its reactive streams API. This is 
something like Rx whre you build streams of data that are also fault tolerant, 
and also feature back pressure to ensure a consumer is not over burdened by a 
fast producer. I have written a lot about Akka before which you can read more 
about here :
<a href="https://sachabarbs.wordpress.com/akka-series/" target="_blank">
https://sachabarbs.wordpress.com/akka-series/</a> where I cover quite a lot of 
Akkas functionality</p>
<h2>What is WebPack?</h2>
<p>We are headed towards an era where browsers will natively support modules, 
and dependencies but we are not there yet. Over the years there have been many 
attempts at JavaScript module management, and dependency tracking of related 
files, such as</p>
<ul>
	<li>ASP MVC bundles (fairly simplistic only bundles no other features)</li>
	<li><a href="http://requirejs.org/docs/commonjs.html" target="_blank">
	CommonJs</a> (require syntax, which is fairly intrusive in how your JS files 
	work)</li>
	<li><a href="http://browserify.org/" target="_blank">Browserify</a> (again 
	fairly intrusive in how your JS files are loaded and what they need to 
	manage dependencies)</li>
	<li><a href="https://www.npmjs.com/" target="_blank">NPM</a> (not really a 
	module manager as such more like NuGet for installing packages)</li>
	<li><a href="https://github.com/systemjs/systemjs" target="_blank">SystemJS</a> 
	(has import/export syntax but a bit more syntax than Webpack)</li>
	<li><a href="https://jspm.io/" target="_blank">JSPM</a> uses
	<a href="https://github.com/systemjs/systemjs" target="_blank">SystemJS</a> 
	(fairly nice but not in as much use as Webpack)</li>
	<li>Various task runners can be used such as Grunt/Gulp to build bundles</li>
</ul>
<p>All of these have there pros/cons, however I think that it is fair to say 
that WebPack has emerged as the defacto standard module manager for JavaScript 
(for now anyway), that supports rich dependency graphs and bundles and also 
supports things like</p>
<ul>
	<li>Transpilers (such as Babel/Typescript/SASS/SCSS/LESS etc etc)</li>
	<li>Sourcemaps (to go from your transpiled JS back to what you wrote)</li>
	<li>Minification</li>
	<li>File hashing (to allow browsers to load latest bundles as it has a 
	different hash)</li>
</ul>
<p>This is kind of what you get with webpack, where it is very clever about 
preserving the dependency graph and the bundles created, and allows you to use 
things like <code>export </code>and <code>import </code>to manage your inter 
dependencies</p>
<p><img alt="" height="286" src="webpack1.png" width="630"></p>
<p>&nbsp;</p>
<h2>What is Babel?</h2>
<p><a href="https://babeljs.io/" target="_blank">Babel</a> is a very neat 
JavaScript library that allows you to use next generation JavaScript syntax now, 
even if your targetted browser doesn&#39;t suport the syntax you are trying to use. 
Is is installed via the Node Packager Manager (NPM) and is one part of you 
transpilation pipeline. For this article we push stuff through TypeScript 
transpiler -&gt; Babel transpiler and the final result is JavaScript that can be 
sent ot the browser.</p>
<p>Using babel this is the sort of things you will be able to do, where native 
browser support for these may be varied, or not supported at all</p>
<p><img alt="" height="308" src="babel1.png" width="500"></p>
<h2>What is SASS/SCSS/LESS</h2>
<p>I guess if you have used HTML you will have certainluy used CSS. Now CSS is 
great, but it lacks certain things such as</p>
<ul>
	<li>Variables</li>
	<li>Heirachy selectors</li>
	<li>Mixins</li>
</ul>
<p>This is something that SASS/SCSS fixes. In much the same way that things like 
Typescript are transpiled to JavaScript, SASS/SCSS is transpiled to CSS.</p>
<p>By using SCSS you are now able to do things like this, note the variables</p>
<pre lang="css">
$blue: #3bbfce;
$margin: 16px;

.content_navigation {
  border-color: $blue;
  color: darken($blue, 10%);
}

.border {
  padding: $margin / 2;
  margin: $margin / 2;
  border-color: $blue;
}</pre>
<h2>What is React?</h2>
<p>Unless you have been living under a rock you will have heard/used/seen
<a href="https://reactjs.org/" target="_blank">React</a>. React is maintained 
and developed by Facebook, and it is a JavaScript library for building user 
interfaces. It is not as much as a framework as say something like Angular is, 
and it is really just the &quot;View&quot; part of the typical MVC puzzle that is so 
prevelant in modern JS UI libraries/frameworks. It is declarative, and component 
centric. It is accepted that a React app would be made up of many smaller 
components. I can&#39;t give you a full walkthrough of React here, but we will 
certainly see more React code/components as the article demo code is dissected 
below</p>
<h2>What is TypeScript?</h2>
<p><a href="https://www.typescriptlang.org/" target="_blank">Typescript</a>&nbsp; 
is a Microsoft offering that attempts to bring better typings and other useful 
constructs/language features to JavaScript. As TypeScript is a superset of 
JavaScript, existing JavaScript programs are also valid TypeScript programs. 
Typescript files will get transpiled into regular javascript files via a 
Typescript compiler (or in the case of WebPack via a Webpack loader)</p>
<p>Some of the features that TypeScript brings to the table are</p>
<ul>
	<li>Types</li>
	<li>Interfaces</li>
	<li>Parameter types</li>
	<li>Enums</li>
	<li>Generics</li>
</ul>
<p>The demo article that goes with this makes a lot of use of TypeScript 
(particularly TSX which is a TypeScript verison of a React JSX file), and will 
also make use of a nice
<a href="https://en.wikipedia.org/wiki/Inversion_of_control" target="_blank">
Inversion Of Control</a> container for TypeScript called
<a href="https://github.com/inversify/InversifyJS" target="_blank">Inversify</a>.</p>
<h1>The app</h1>
<p>The next set of sections will walk through the demo app. I have decided to 
take a workflow approach to describing the app, and as such will walk/talk 
through each of the workflows, which I think is the best way to do it</p>
<p>The app has MANY moving parts, but can largely be broken down into the 
following areas</p>
<ul>
	<li>Play backend API (scala)</li>
	<li>React front end (TypeScript)</li>
	<li>Kafka Streams (scala)</li>
</ul>
<p>We will get to all of these parts, but before that let&#39;s examine some of the 
stuff that helps the front end work get of the ground</p>
<h3>NPM requirements</h3>
<p>The demo project uses quite a few components, such as</p>
<ul>
	<li>TypeScript</li>
	<li>React</li>
	<li>Babel</li>
	<li>RX</li>
	<li>SCSS</li>
	<li>Various other libraries</li>
</ul>
<p>As such we need a way to pull all these packages into use, so for that and 
the front end side of things we use NPM which you will need to have installed. 
The following shows the NPM dependencies for the demo app <code>
PlayBackEndApi/FrontEndWebSite/package.json</code> file</p>
<pre lang="js">
{
  "name": "task1webpackconfig",
  "version": "1.0.0",
  "description": "webpack 2 + TypeScript 2 + Babel example",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/sachabarber/MadCapIdea.git"
  },
  "keywords": [
    "babel",
    "typescript",
    "webpack",
    "bundling",
    "javascript",
    "npm"
  ],
  "author": "sacha barber",
  "homepage": "https://github.com/sachabarber/MadCapIdea#readme",
  "dependencies": {
    "bootstrap": "^3.3.7",
    "inversify": "^4.1.0",
    "jquery": "^3.2.1",
    "lodash": "^4.17.4",
    "react": "^15.5.4",
    "react-bootstrap": "^0.28.1",
    "react-bootstrap-validation": "^0.1.11",
    "react-dom": "^15.5.4",
    "react-google-maps": "^7.0.0",
    "react-measure": "^2.0.2",
    "react-router": "^3.0.5",
    "react-stars": "^2.1.0",
    "reflect-metadata": "^0.1.10",
    "revalidator": "^0.3.1",
    "rx": "^4.1.0",
    "webpack": "^2.5.1",
    "webpack-merge": "^4.1.0"
  },
  "devDependencies": {
    "@types/jquery": "^2.0.43",
    "@types/lodash": "^4.14.63",
    "@types/react": "^15.0.24",
    "@types/react-dom": "^15.5.0",
    "@types/rx": "^4.1.1",
    "awesome-typescript-loader": "^3.1.3",
    "babel-core": "^6.24.1",
    "babel-loader": "^7.0.0",
    "babel-preset-es2015": "^6.24.1",
    "babel-preset-es2015-native-modules": "^6.9.4",
    "babel-preset-react": "^6.24.1",
    "css-loader": "^0.28.1",
    "extract-text-webpack-plugin": "^2.1.0",
    "file-loader": "^0.11.1",
    "html-webpack-plugin": "^2.28.0",
    "node-sass": "^4.5.2",
    "on-build-webpack": "^0.1.0",
    "sass-loader": "^6.0.3",
    "source-map-loader": "^0.2.1",
    "typescript": "^2.3.2",
    "url-loader": "^0.5.8",
    "webpack": "^2.4.1"
  },
  "scripts": {
    "build-dev": "webpack -d --config webpack.develop.js",
    "build-prod": "webpack --config webpack.production.js"
  }
}
</pre>
<h3>Babel config</h3>
<p>As stated above the demo project makes use of 
<a href="https://babeljs.io/" target="_blank">Babeljs.io</a> to use future state 
JavaScript now. As such we also need to supply a small Babel config file (<code>PlayBackEndApi/FrontEndWebSite/.babelrc</code>), 
this is shown below, where we opt to use the ES2015/React presets</p>
<pre lang="js">{ "presets": ["es2015","react"] }</pre>
<h3>TypeScript config</h3>
<p>The demo also makes use of&nbsp;
<a href="https://www.typescriptlang.org" target="_blank">TypeScript</a> which also need some specific 
configuration. As such we also need to supply a small TypeScript config file (<code>PlayBackEndApi/FrontEndWebSite/tsconfig.json</code>), 
this is shown below, the full set of
<a href="https://www.typescriptlang.org" target="_blank">TypeScript</a> options 
can also be found here :
<a href="https://www.typescriptlang.org/docs/handbook/tsconfig-json.html" target="_blank">
https://www.typescriptlang.org/docs/handbook/tsconfig-json.html</a></p>
<pre lang="js">
{
  "compilerOptions": {
    "allowSyntheticDefaultImports": true,
    "moduleResolution": "node",
    "outDir": "./dist/",
    "sourceMap": true,
    "noImplicitAny": false,
    "module": "es2015",
    "target": "es5",
    "lib": ["es6", "dom"],
    "jsx": "react",
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "types" : ["jquery", "lodash", "react", "react-dom", "reflect-metadata"]
  },
    "include": [
        "./src/**/*"
    ]
}
</pre>
<h3>Sourcemap files</h3>
<p>Sourcemaps are a magical thing that allow you to write your JavaScript in 
TypeScript say which is then possibly run through other transpilers (such as 
Babel) and then webpack where it is bundled according to your rules, where you 
then send the JavaScript to the browser. That sounds great, but do you write 
code write code first time, I don&#39;t, and constantly need to debug stuff.</p>
<p>So if I wrote stuff in TypeScript and that gets turned into plain vanilla 
JavaScript, how on earth do I make sense of the stuff that is in the browser?</p>
<p>Well that is where sourcemaps come in, the literally send a clever map that 
allows you to put a break point into your source code (which will be sent to the 
browser, ideally only in development phases) and it will know how to translate 
that breakpoint into the correct place/line in the transpiled vanilla JavaScript 
that the browser is using.</p>
<p>Webpack has in built support for sourcemaps (phew)</p>
<p>The best write up of source maps I have seen is this one :
<a href="https://www.html5rocks.com/en/tutorials/developertools/sourcemaps/">
https://www.html5rocks.com/en/tutorials/developertools/sourcemaps/</a></p>
<div>
<p style="background:yellow; margin:3px; border:1px black solid">It should be noted that sourcemaps should only be used in development phases, 
as in production would want to minify your JavaScript too.</p>
</div>
<h3>How does Webpack/Play work with this?</h3>
<p>WebPack has this concept of loaders that are what gets used to load different 
file types. So for example you can use a TypeScript loader that gets piped 
through a babel loader, where the final result will be vanilla JavaScript.</p>
<ul>
	<li>You can also control how you final bundle will work, what name it has, 
	where is will be generated etc 
etc</li>
	<li>How minification will work</li>
	<li>Configure loaders</li>
	<li>Turn on SourceMap</li>
	<li>Configure things like <a href="https://jquery.com/" target="_blank">jquery</a> and
	<a href="https://lodash.com/" target="_blank">lodash</a> to appear in the usual 
places as <code>$</code> and <code>_</code> respectively</li>
</ul>
<p>Perhaps its best to see the demo codes WebPack file which looks like this</p>
<p><strong>PlayBackEndApi/FrontEndWebSite/webpack.config.js</strong></p>
<pre lang="js">
let _ = require('lodash');
let webpack = require('webpack');
let path = require('path');
let fs = require("fs");
let WebpackOnBuildPlugin = require('on-build-webpack');
let ExtractTextPlugin = require('extract-text-webpack-plugin');
let HtmlWebpackPlugin = require('html-webpack-plugin');

let babelOptions = {
    "presets": ["es2015", "react"]
};

function isVendor(module) {
    return module.context &amp;&amp; module.context.indexOf('node_modules') !== -1;
}

let entries = {
    index: './src/index.tsx',
    indexCss: './scss/index.scss'

};

//build it to the Play Framework public folder, which is services by the assets controller
let buildDir = path.resolve(__dirname, '../public/dist');

module.exports = {

    context: __dirname,

    entry: entries,

    output: {
        filename: '[name].bundle.[hash].js',
        path: buildDir,
		//this is to make it play nice with the Play Framework Assets controllers
		//that deals with static data
		publicPath: '/assets/dist'
    },

    // these break for node 5.3+ when building WS stuff
    node: {
        fs: 'empty'
    },

    watch: true,

    devServer: {
        open: true, // to open the local server in browser
        contentBase: __dirname,
    },

    // Enable sourcemaps for debugging webpack's output.
    devtool: "source-map",

    resolve: {
        extensions: [".tsx", ".ts", ".js", ".jsx"],
        modules: [path.resolve(__dirname, "src"), "node_modules"]
    },

    plugins: [

        //The ProvidePlugin makes a module available as a variable in every other
        //module required by webpack
        new webpack.ProvidePlugin({
            $: "jquery",
            jQuery: "jquery",
            "window.jQuery": "jquery"
        }),

        // creates a common vendor js file for libraries in node_modules
        new webpack.optimize.CommonsChunkPlugin({
            names: ['vendor'],
            minChunks: function (module, count) {
                return isVendor(module);
            }
        }),

        // creates a common vendor js file for libraries in node_modules
        new webpack.optimize.CommonsChunkPlugin({
            name: "commons",
            chunks: _.keys(entries),
            minChunks: function (module, count) {
                return !isVendor(module) &amp;&amp; count &gt; 1;
            }
        }),


        //will unlink unused files on a build
        //http://stackoverflow.com/questions/40370749/how-to-remove-old-files-from-the-build-dir-when-webpack-watch
        new WebpackOnBuildPlugin(function (stats) {
            const newlyCreatedAssets = stats.compilation.assets;

            const unlinked = [];
            fs.readdir(path.resolve(buildDir), (err, files) =&gt; {
                files.forEach(file =&gt; {
                    if (file != "fonts") {
                        if (!newlyCreatedAssets[file]) {
                            fs.unlink(path.resolve(buildDir + '\\' + file));
                            unlinked.push(file);
                        }
                    }
                });
                if (unlinked.length &gt; 0) {
                    console.log('Removed old assets: ', unlinked);
                }
            })
        }),

        //scss/sass files extracted to common css bundle
        new ExtractTextPlugin({
            filename: '[name].bundle.[hash].css',
            allChunks: true,
        }),

        new HtmlWebpackPlugin({
            filename: 'index.html',
            template: 'template.html',
        })
    ],

    module: {
        rules: [
            // All files with a '.ts' or '.tsx' extension will be handled by 'awesome-typescript-loader' 1st 
            // then 'babel-loader'
            // NOTE : loaders run right to left (think of them as a cmd line pipe)
            {
                test: /\.ts(x?)$/,
                exclude: /node_modules/,
                use: [
                  {
                      loader: 'babel-loader',
                      options: babelOptions
                  },
                  {
                      loader: 'awesome-typescript-loader'
                  }
                ]
            },


            // All files with a .css extenson will be handled by 'css-loader'
            {
                test: /\.css$/,
                loader: ExtractTextPlugin.extract(['css-loader?importLoaders=1']),
            },

            // All files with a .scss|.sass extenson will be handled by 'sass-loader'
            {
                test: /\.(sass|scss)$/,
                loader: ExtractTextPlugin.extract(['css-loader', 'sass-loader'])
            },


            // All files with a '.js' extension will be handled by 'babel-loader'.
            {
                test: /\.js$/,
                exclude: /node_modules/,
                use: [
                  {
                      loader: 'babel-loader',
                      options: babelOptions
                  }
                ]
            },

            { 
                test: /\.png$/, 
                loader: "url-loader?limit=100000" 
            },
      
            { 
                test: /\.jpg$/, 
                loader: "file-loader" 
            },

            {
                test: /\.woff(\?.*)?$/,
                loader: 'url-loader?prefix=fonts/&amp;name=fonts/[name].[ext]&amp;limit=10000&amp;mimetype=application/font-woff'
            },

            {
                test: /\.woff2(\?.*)?$/,
                loader: 'url-loader?prefix=fonts/&amp;name=fonts/[name].[ext]&amp;limit=10000&amp;mimetype=application/font-woff2'
            },

            {
                test: /\.ttf(\?.*)?$/,
                loader: 'url-loader?prefix=fonts/&amp;name=fonts/[name].[ext]&amp;limit=10000&amp;mimetype=application/octet-stream'
            },

            {
                test: /\.eot(\?.*)?$/, loader: 'file-loader?prefix=fonts/&amp;name=fonts/[name].[ext]'
            },

            {
                test: /\.svg(\?.*)?$/,
                loader: 'url-loader?prefix=fonts/&amp;name=fonts/[name].[ext]&amp;limit=10000&amp;mimetype=image/svg+xml'
            },

            // All output '.js' files will have any sourcemaps re-processed by 'source-map-loader'.
            {
                enforce: "pre",
                test: /\.js$/,
                loader: "source-map-loader"
            }
        ]
    }
};</pre>
<p>Of particular note is this part</p>
<pre lang="js">
output: {
        filename: '[name].bundle.[hash].js',
        path: buildDir,
		//this is to make it play nice with the Play Framework Assets controllers
		//that deals with static data
		publicPath: '/assets/dist'
    }
</pre>
<p>What that is doing is using a hash for the file name, such that the browser 
would immediately see a change in the file, so would reload it, and not cache 
old JavaScript. The other part of this is where the file gets generated. As this 
&quot;front end&quot; part still needs to be hosted in back end (<a href="https://www.playframework.com/documentation/2.5.x/Home" target="_blank">Play 
framework</a> for this article) we need to ensure that the final JavaScript ends 
up in a location that the
<a href="https://www.playframework.com/documentation/2.5.x/Home" target="_blank">
Play framework</a> is able to render. For this article this means the static
<a href="https://www.playframework.com/documentation/2.5.x/Home" target="_blank">
Play framework</a> route which is configured as follows in the <code>PlayBackEndApi/routes </code>file in the <code>PlayBackEndApi </code>project</p>
<pre>
GET   /assets/*file                            controllers.Assets.at(path="/public", file)
</pre>
<p><strong>PlayBackEndApi/FrontEndWebSite/webpack.develop.js</strong></p>
<p>Where we might have a specialized develop phase variant (see how we use the 
base file <code>webpack.config.js</code> as a base) file that 
looks like this </p>
<pre lang="js">
let commonConfig = require('./webpack.config.js');
let webpack = require('webpack');
let Merge = require('webpack-merge');

module.exports = function (env) {
    return Merge(commonConfig, {})
}
</pre>
<p><strong>PlayBackEndApi/FrontEndWebSite/webpack.production.js</strong></p>
<p>Where we might have a specialized production phase variant (see how we use 
the base file <code>webpack.config.js</code> as a base) file that 
looks like this, where we do things like this to make the emitted JavaScript 
production like</p>
<ul>
	<li>Minify it</li>
	<li>Strip comments</li>
	<li>Strip console.log (some browsers don&#39;t have it)</li>
	<li>Don&#39;t enable SourceMaps</li>
</ul>
<pre lang="js">
let commonConfig = require('./webpack.config.js');
let webpack = require('webpack');
let Merge = require('webpack-merge');

module.exports = function (env) {
    return Merge(commonConfig, {
        plugins: [
          new webpack.LoaderOptionsPlugin({
              minimize: true,
              debug: false
          }),
          new webpack.optimize.UglifyJsPlugin({
              // Eliminate comments
              comments: false,
              beautify: false,
              mangle: {
                  screw_ie8: true,
                  keep_fnames: true
              },
              compress: {
                  screw_ie8: true,

                  // remove warnings
                  warnings: false,

                  // Drop console statements
                  drop_console: true
              },
              comments: false,
              sourceMap: false
          })
        ]
    })
}</pre>
<h3>The SPA</h3>
<p>So the React front end is really a Single Page Application, as such you can 
expect to find a single page. So just where is that single page?</p>
<p>We we need to go back to some of the stuff in the <code>webpack.config.js</code> 
file, specifically these bits</p>
<pre lang="js">


//build it to the Play Framework public folder, which is services by the assets controller
let buildDir = path.resolve(__dirname, '../public/dist');

output: {
        filename: '[name].bundle.[hash].js',
        path: buildDir,
		//this is to make it play nice with the Play Framework Assets controllers
		//that deals with static data
		publicPath: '/assets/dist'
    },
....    
....    
....    
....    
new HtmlWebpackPlugin({
            filename: 'index.html',
            template: 'template.html',
        })
        </pre>
<p>What this is doing is saying that Webpack will try and generate a file called 
i<code>ndex.html</code> by using a template called<code> template.html</code> 
and the final file will be put in a relative path called <code>/assets/dist</code>, 
which if you go back a bit was mapped using the&nbsp; following in the <code>PlayBackEndApi/routes </code>file in the <code>PlayBackEndApi </code>project</p>
<pre>
GET   /assets/*file                            controllers.Assets.at(path="/public", file)
</pre>
<p><strong>PlayBackEndApi/FrontEndWebSite/template.html</strong></p>
<p>So what does the <code>template.html</code> file look like, well here it is, where it also includes a CDN references to Google maps API as we use that in this article</p>
<pre lang="js">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;title&gt;Hello React!&lt;/title&gt;
    &lt;script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBVtreRNA537_WsNSn2_kOiz3Xhm8w6pEo"
            type="text/javascript"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div&gt;
        &lt;iframe id="comet" src="/job/streamedJob"&gt;&lt;/iframe&gt;
    &lt;/div&gt;
    &lt;div id="root"&gt;&lt;/div&gt;
    &lt;!-- Main --&gt;
&lt;/body&gt;
&lt;/html&gt;	
</pre>
<p><strong>PlayBackEndApi/public/dist/index.html </strong></p>
<p>So after WebPack has worked its magic, what does the final file look like. 
Well it looks like this</p>
<pre lang="html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;title&gt;Hello React!&lt;/title&gt;
    &lt;script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBVtreRNA537_WsNSn2_kOiz3Xhm8w6pEo"
            type="text/javascript"&gt;&lt;/script&gt;
&lt;link href="/assets/dist/vendor.bundle.5c5feaa8663412cf31c5.css" rel="stylesheet"&gt;
&lt;link href="/assets/dist/indexCss.bundle.5c5feaa8663412cf31c5.css" rel="stylesheet"&gt;&lt;/head&gt;
&lt;body&gt;
    &lt;div&gt;
        &lt;iframe id="comet" src="/job/streamedJob"&gt;&lt;/iframe&gt;
    &lt;/div&gt;
    &lt;div id="root"&gt;&lt;/div&gt;
    &lt;!-- Main --&gt;
&lt;script type="text/javascript" src="/assets/dist/vendor.bundle.5c5feaa8663412cf31c5.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="/assets/dist/index.bundle.5c5feaa8663412cf31c5.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;		
</pre>
<p>See how the correct Css and JavaScript files have been placed into the 
HEAD/Script tags automatically, this is great I think, and they also have nice 
hashes as part of the file name, to allow the browser caches to be easily 
invalidated</p>
<p><strong>Play &quot;Home&quot; route</strong></p>
<p>So that&#39;s great but how does this page get served up. Well the trick to that 
lies in this Play framework route entry</p>
<pre>
# Home page
GET   /                                        controllers.HomeController.index()
</pre>
<p>Which has this server side code to serve the route</p>
<pre lang="scala">
package controllers

import javax.inject.Inject
import play.api.mvc.{Action, Controller}

class HomeController @Inject() (environment: play.api.Environment)
  extends Controller {

  def index() = Action {
    val fullpath = s"${environment.rootPath}\\public\\dist\\index.html"
    val htmlContents = scala.io.Source.fromFile(fullpath).mkString
    Ok(htmlContents).as("text/html")
  }

}</pre>
<p>&nbsp;</p>
<h2>Routing</h2>
<p>As I stated above this demo is a Singlle Page App (SPA) type of app. So how 
is that done. That is done in this file <code>
PlayBackEndApi/FrontEndWebSite/src/index.tsx</code>, which is also set as an 
entry point in the WebPack <code>webpack.config.js</code> file.</p>
<pre lang="js">
let entries = {
    index: './src/index.tsx',
    .....
    .....
    .....
    .....
};

//build it to the Play Framework public folder, which is services by the assets controller
let buildDir = path.resolve(__dirname, '../public/dist');

module.exports = {

    context: __dirname,

    entry: entries,
	
	
	.....
	.....
	.....
	.....
	.....

}
</pre>
<p><strong>PlayBackEndApi/FrontEndWebSite/src/index.tsx</strong></p>
<p>Where the actual routing work is done like this, where the main top level 
components will be</p>
<ul>
	<li>Login</li>
	<li>Register</li>
	<li>Logout</li>
	<li>CreateJob</li>
	<li>ViewJob</li>
	<li>ViewRating</li>
</ul>
<p>Some of which are conditional routes depending on whether you are logged in 
or not. &nbsp;</p>
<pre lang="js">
import * as React from "react";
import * as ReactDOM from "react-dom";
import 'bootstrap/dist/css/bootstrap.css';
import {
    Nav,
    Navbar,
    NavItem,
    NavDropdown,
    MenuItem,
    Button
} from "react-bootstrap";
import { Router, Route, hashHistory } from 'react-router'
import { Login } from "./Login";
import { Logout } from "./Logout";
import { Register } from "./Register";
import { CreateJob } from "./CreateJob";
import { ViewJob } from "./ViewJob";
import { ViewRating } from "./ViewRating";
import { ContainerOperations } from "./ioc/ContainerOperations";
import { AuthService } from "./services/AuthService";
import { JobService } from "./services/JobService";
import { JobStreamService } from "./services/JobStreamService";
import { PositionService } from "./services/PositionService";
import { TYPES } from "./types";
import Rx from 'rx';

let authService = ContainerOperations.getInstance().container.get&lt;AuthService&gt;(TYPES.AuthService);
let jobService = ContainerOperations.getInstance().container.get&lt;JobService&gt;(TYPES.JobService);
let jobStreamService = ContainerOperations.getInstance().container.get&lt;JobStreamService&gt;(TYPES.JobStreamService);
let positionService = ContainerOperations.getInstance().container.get&lt;PositionService&gt;(TYPES.PositionService);
jobStreamService.init();


export interface MainNavProps {
    authService: AuthService;
    jobService: JobService;
    jobStreamService: JobStreamService;
    positionService: PositionService;

}

export interface MainNavState {
    isLoggedIn: boolean;
}

class MainNav extends React.Component&lt;MainNavProps, MainNavState&gt; {

    private _subscription: any;

    constructor(props: any) {
        super(props);
        console.log(props);
        this.state = {
            isLoggedIn: false
        };
    }

    componentWillMount() {
        this._subscription = this.props.authService.getAuthenticationStream()
            .subscribe(isAuthenticated =&gt; {
                this.state = {
                    isLoggedIn: isAuthenticated
                };
                if (this.state.isLoggedIn) {
                    hashHistory.push('/createjob');
                }
                else {
                    hashHistory.push('/');
                }
            });
    }

    componentWillUnmount() {
        this._subscription.dispose();
    }

    render() {
        return (
            this.state.isLoggedIn ?
                &lt;Navbar collapseOnSelect&gt;
                    &lt;Navbar.Header&gt;
                        &lt;Navbar.Brand&gt;
                            &lt;span&gt;Simple Kafka-Uber&lt;/span&gt;
                        &lt;/Navbar.Brand&gt;
                        &lt;Navbar.Toggle /&gt;
                    &lt;/Navbar.Header&gt;
                    &lt;Navbar.Collapse&gt;
                        &lt;Nav pullRight&gt;
                            &lt;NavItem eventKey={2} href='#/logout'&gt;Logout&lt;/NavItem&gt;
                            &lt;NavItem eventKey={2} href='#/createjob'&gt;Create Job&lt;/NavItem&gt;
                            &lt;NavItem eventKey={2} href='#/viewjob'&gt;View Job&lt;/NavItem&gt;
                            &lt;NavItem eventKey={2} href='#/viewrating'&gt;View Rating&lt;/NavItem&gt;
                        &lt;/Nav&gt;
                    &lt;/Navbar.Collapse&gt;
                &lt;/Navbar&gt; :
                &lt;Navbar pullRight collapseOnSelect&gt;
                    &lt;Navbar.Header&gt;
                        &lt;Navbar.Brand&gt;
                            &lt;span&gt;Simple Kafka-Uber&lt;/span&gt;
                        &lt;/Navbar.Brand&gt;
                        &lt;Navbar.Toggle /&gt;
                    &lt;/Navbar.Header&gt;
                    &lt;Navbar.Collapse&gt;
                    &lt;/Navbar.Collapse&gt;
                &lt;/Navbar&gt;
        )
    }
}

class App extends React.Component&lt;undefined, undefined&gt; {
    render() {
        return (
            &lt;div&gt;
                &lt;div&gt;
                    &lt;MainNav
                        authService={authService}
                        jobService={jobService}
                        jobStreamService={jobStreamService}
                        positionService={positionService}
                    /&gt;
                    {this.props.children}
                &lt;/div&gt;
            &lt;/div&gt;
        )
    }
}


ReactDOM.render((
    &lt;Router history={hashHistory}&gt;
        &lt;Route component={App}&gt;
            &lt;Route
                path="/"
                component={Login}
                authService={authService} /&gt;
            &lt;Route
                path="/register"
                component={Register}
                authService={authService} /&gt;
            &lt;Route
                path="/logout"
                component={Logout}
                authService={authService}
                jobService={jobService}
                positionService={positionService} /&gt;
            &lt;Route
                path="/createjob"
                component={CreateJob}
                authService={authService}
                jobService={jobService}
                positionService={positionService} /&gt;
            &lt;Route
                path="/viewjob"
                component={ViewJob}
                authService={authService}
                jobService={jobService}
                jobStreamService={jobStreamService}
                positionService={positionService} /&gt;
            &lt;Route
                path="/viewrating"
                component={ViewRating}
                authService={authService} /&gt;
        &lt;/Route&gt;
    &lt;/Router&gt;
), document.getElementById('root'));
</pre>
<p>This makes use of &nbsp;<code>ReactRouter </code>version 3.0.5 to do the 
routing within the SPA, and also make use of <a href="https://react-bootstrap.github.io/" target="_blank">React-Bootstrap</a> 
for rendering the
<a href="https://react-bootstrap.github.io/components/navbar/" target="_blank">
NavBar</a></p>
<p>This TypeScipt also hooks up a RxJS subcription to determine whether you are 
logged in/out, this is done using the following injectable service <code>
PlayBackEndApi/FrontEndWebSite/src/services/AuthService.ts</code></p>
<pre lang="js">
import { injectable, inject } from "inversify";
import { TYPES } from "../types";
import Rx from 'rx';

@injectable()
export class AuthService {

    private _isAuthenticated: boolean;
    private _authenticatedSubject = new Rx.Subject&lt;boolean&gt;();

    constructor() {

    }

    clearUser = (): void =&gt; {
        this._isAuthenticated = false;
        sessionStorage.removeItem('currentUserProfile');
        this._authenticatedSubject.onNext(false);
    }

    storeUser = (currentProfile: any): void =&gt; {

        if (currentProfile == null || currentProfile == undefined)
            return;

        this._isAuthenticated = true;
        sessionStorage.setItem('currentUserProfile', JSON.stringify(currentProfile));
        this._authenticatedSubject.onNext(true);
    }

    userName = (): string =&gt; {
        var userProfile = JSON.parse(sessionStorage.getItem('currentUserProfile'));
        return userProfile.user.fullName;
    }

    user = (): any =&gt; {
        var userProfile = JSON.parse(sessionStorage.getItem('currentUserProfile'));
        return userProfile.user;
    }

    userEmail = (): string =&gt; {
        var userProfile = JSON.parse(sessionStorage.getItem('currentUserProfile'));
        return userProfile.user.email;
    }

    isDriver = (): boolean =&gt; {
        var userProfile = JSON.parse(sessionStorage.getItem('currentUserProfile'));
        return userProfile.isDriver;
    }

    isAuthenticated = (): boolean =&gt; {
        return this._isAuthenticated;
    }

    getAuthenticationStream = (): Rx.Observable&lt;boolean&gt; =&gt; {
        return this._authenticatedSubject.asObservable();
    }
}</pre>
<p>&nbsp;</p>
<h2>Some common React / Bootstrap UI components</h2>
<p>As with any UI work, you will inevitably end up where you need some core 
components that you re-use over and over again. For the demo app I had these 3 
reusable React components that make use of React/<a href="https://react-bootstrap.github.io/" target="_blank">React-Bootstrap</a></p>
<p><strong>YesNoDialog</strong></p>
<p>This represents a generic re-usable yes/no dialog that can be triggered, here 
is the code for this one. The important part is that the various prop values can 
be controlled via the parent component state values</p>
<pre lang="js">
import * as React from "react";
import * as ReactDOM from "react-dom";
import * as _ from "lodash";
 
import 'bootstrap/dist/css/bootstrap.css';
import
{
    Button, 
    Modal
} from "react-bootstrap";
 
 
//TODO : Fix this
export interface YesNoDialogProps {
    headerText: string;
    theId: string;
    launchButtonText: string;
    yesCallBack: any;
    noCallBack: any;
}
 
export interface YesNoDialogState {
    showModal: boolean;
}
 
 
export class YesNoDialog extends React.Component&lt;YesNoDialogProps, YesNoDialogState&gt; {
 
    constructor(props) {
        super(props);
        console.log(this.props);
        //set initial state
        this.state = {
            showModal: false
        };
    }
 
    _yesClicked = () =&gt; {
        this.setState({ showModal: false });
        this.props.yesCallBack();
    }
 
    _noClicked = () =&gt; {
        this.setState({ showModal: false });
        this.props.noCallBack();
    }
 
    _close = () =&gt; {
        this.setState({ showModal: false });
    }
 
    _open = () =&gt; {
        this.setState({ showModal: true });
    }
 
    render() {
        return (
            &lt;div className="leftFloat"&gt;
 
                &lt;Button
                    id={this.props.theId}
                    type='button'
                    bsSize='small'
                    bsStyle='primary'
                    onClick={this._open}&gt;{this.props.launchButtonText}&lt;/Button&gt;
 
                &lt;Modal show={this.state.showModal} onHide={this._close}&gt;
                    &lt;Modal.Header closeButton&gt;
                        &lt;Modal.Title&gt;{ this.props.headerText }&lt;/Modal.Title&gt;
                    &lt;/Modal.Header&gt;
                    &lt;Modal.Body&gt;
                        &lt;h4&gt;Are you sure?&lt;/h4&gt;
                    &lt;/Modal.Body&gt;
                    &lt;Modal.Footer&gt;
                        &lt;Button
                            type='button'
                            bsSize='small'
                            bsStyle='primary'
                            onClick={this._yesClicked}&gt;Yes&lt;/Button&gt;
                        &lt;Button
                            type='button'
                            bsSize='small'
                            bsStyle='danger'
                            onClick={this._noClicked}&gt;Cancel&lt;/Button&gt;
                    &lt;/Modal.Footer&gt;
                &lt;/Modal&gt;
            &lt;/div&gt;
        );
    }
}
</pre>
<p>This looks like this when rendered</p>
<h2><img alt="" height="226" src="yesnodialog.png" width="600"></h2>

<p><strong>OkDialog</strong></p>
<p>This represents a generic re-usable ok dialog that can be triggered, here is the code for this one. The important part is that the various prop values can be controlled via the parent component state values</p>
<pre lang="js">
import * as React from "react";
import * as ReactDOM from "react-dom";
import * as _ from "lodash";
 
import 'bootstrap/dist/css/bootstrap.css';
import
{
    Button, 
    Modal
} from "react-bootstrap";
 
 
//TODO : Fix this
export interface OkDialogProps {
    headerText: string;
    bodyText: string;
    open: boolean;
    okCallBack: any;
}
 
export interface OkDialogState {
    showModal: boolean;
}
 
 
export class OkDialog extends React.Component&lt;OkDialogProps, OkDialogState&gt; {
 
    constructor(props) {
        super(props);
        console.log(this.props);
        //set initial state
        this.state = {
            showModal: false
        };
    }
 
    componentDidMount() {
        if (this.props.open === true) {
            this.setState({ showModal: true });
        }
    }
 
    _okClicked = () =&gt; {
        this.setState({ showModal: false });
        this.props.okCallBack();
    }
 
    _close = () =&gt; {
        this.setState({ showModal: false });
        this.props.okCallBack();
    }
 
    _open = () =&gt; {
        this.setState({ showModal: true });
    }
 
    render() {
        return (
            &lt;div className="leftFloat"&gt;
 
                &lt;Modal show={this.state.showModal} onHide={this._close}&gt;
                    &lt;Modal.Header closeButton&gt;
                        &lt;Modal.Title&gt;{ this.props.headerText }&lt;/Modal.Title&gt;
                    &lt;/Modal.Header&gt;
                    &lt;Modal.Body&gt;
                        &lt;h4&gt;{this.props.bodyText}&lt;/h4&gt;
                    &lt;/Modal.Body&gt;
                    &lt;Modal.Footer&gt;
                        &lt;Button
                            type='button'
                            bsSize='small'
                            bsStyle='primary'
                            onClick={this._okClicked}&gt;Ok&lt;/Button&gt;
                    &lt;/Modal.Footer&gt;
                &lt;/Modal&gt;
            &lt;/div&gt;
        );
    }
}
</pre>
<p>This looks like this when rendered</p>

<h2><img alt="" height="221" src="OkDialog.png" width="600"></h2>
<p><strong>RatingDialog</strong></p>
<p>This represents a generic re-usable rating control where rating can be from 1-5, here is the code for this one. The important part is that the various prop values can be controlled via the parent component state values</p>
<pre lang="js">
import * as React from "react";
import * as ReactDOM from "react-dom";
import * as _ from "lodash";
 
import 'bootstrap/dist/css/bootstrap.css';
import
{
    Button, 
    Modal
} from "react-bootstrap";
 
 
import ReactStars from 'react-stars';
 
 
export interface RatingDialogProps {
    headerText: string;
    theId: string;
    okCallBack: any;
}
 
export interface RatingDialogState {
    showModal: boolean;
    rating: number;
}
 
 
export class RatingDialog extends React.Component&lt;RatingDialogProps, RatingDialogState&gt; {
 
    constructor(props) {
        super(props);
        console.log(this.props); 
        //set initial state
        this.state = {
            showModal: false,
            rating:0
        };
    }
 
    _close = () =&gt; {
        this.setState(
            {
                showModal: false,
                rating:0
            }
        );
    }
 
    _open = () =&gt; {
        this.setState(
            {
                showModal: true,
                rating: 0
            }
        );
    }
 
    _ratingChanged = (newRating) =&gt; {
        console.log(newRating)
        this.setState(
            {
                rating: newRating
            }
        );
    }
 
    _okClicked = () =&gt; {
        this._close();
        this.props.okCallBack();
    }
 
    render() {
        return (
            &lt;div className="leftFloat"&gt;
 
                &lt;Button
                    id={this.props.theId}
                    type='button'
                    bsSize='small'
                    bsStyle='primary'
                    onClick={this._open}&gt;Complete&lt;/Button&gt;
 
                &lt;Modal show={this.state.showModal} onHide={this._close}&gt;
                    &lt;Modal.Header closeButton&gt;
                        &lt;Modal.Title&gt;{ this.props.headerText }&lt;/Modal.Title&gt;
                    &lt;/Modal.Header&gt;
                    &lt;Modal.Body&gt;
                        &lt;h4&gt;Give your rating between 1-5&lt;/h4&gt;
                        &lt;ReactStars count={5}
                                    onChange={this._ratingChanged}
                                    size={24}
                                    color2={'#ffd700'} /&gt;
                    &lt;/Modal.Body&gt;
                    &lt;Modal.Footer&gt;
                        &lt;Button
                            type='submit'
                            bsSize='small'
                            bsStyle='primary'
                            onClick={this._okClicked}&gt;Ok&lt;/Button&gt;
                    &lt;/Modal.Footer&gt;
                &lt;/Modal&gt;
            &lt;/div&gt;
        );
</pre>
<p>This looks like this when rendered</p>
<p><img alt="" height="251" src="RatingDialog.png" width="600"></p>
<p>For the rating component I make use of this React library : 
<a href="https://www.npmjs.com/package/react-stars" target="_blank">https://www.npmjs.com/package/react-stars</a></p>

<h2>Registration workflow</h2>
<p><img alt="" height="217" src="loginRegisterFlow.png" width="630"></p>
<p>The registration workflow is pretty much as described above, and uses the 
pieces shown above.</p>
<p>There are 2 types of registration, where we need to capture different data</p>
<ul>
	<li>Passenger registration</li>
	<li>Driver registration</li>
</ul>
<p>We will examine the passenger registration in detail, with the driver 
registration being fairly similiar in nature</p>
<h3><strong>Passenger registration</strong></h3>
<p><img alt="" height="583" src="passreg.png" width="630"></p>
<h4>Registration React component</h4>
<p>This is the main <code>
PlayBackEndApi/FrontEndWebSite/src/PassengerRegistration.tsx</code> file for the React TSX representing the Passenger 
registration component.</p>
<pre lang="js">
import * as React from "react";
import * as ReactDOM from "react-dom";
import { OkDialog } from "./components/OkDialog";
import 'bootstrap/dist/css/bootstrap.css';
import {
    Well,
    Grid,
    Row,
    Col,
    ButtonInput
} from "react-bootstrap";
import { AuthService } from "./services/AuthService";
import { hashHistory } from 'react-router';
import { Form, ValidatedInput } from 'react-bootstrap-validation';
import revalidator from 'revalidator';


let schema = {
    properties: {
        fullName: {
            type: 'string',
            minLength: 8,
            maxLength: 60,
            required: true,
            allowEmpty: false
        },
        email: {
            type: 'string',
            maxLength: 255,
            format: 'email',
            required: true,
            allowEmpty: false
        },
        password: {
            type: 'string',
            minLength: 8,
            maxLength: 60,
            required: true,
            allowEmpty: false
        }
    }
};


export interface PassengerRegistrationProps {
    authService: AuthService;
}


export interface PassengerRegistrationState {
    okDialogOpen: boolean;
    okDialogKey: number;
    okDialogHeaderText: string;
    okDialogBodyText: string;
    wasSuccessful: boolean;
}

export class PassengerRegistration extends React.Component&lt;PassengerRegistrationProps, PassengerRegistrationState&gt; {

    constructor(props: any) {
        super(props);
        this.state = {
            okDialogHeaderText: '',
            okDialogBodyText: '',
            okDialogOpen: false,
            okDialogKey: 0,
            wasSuccessful: false
        };
    }

    render() {
        return (
            &lt;Form className="submittable-form-inner"
                // Supply callbacks to both valid and invalid
                // submit attempts
                validateAll={this.validateForm}
                onInvalidSubmit={this.handleInvalidSubmit}
                onValidSubmit={this.handleValidSubmit}&gt;
                &lt;Grid&gt;
                    &lt;Row className="show-grid"&gt;
                        &lt;Col xs={10} md={6}&gt;
                            &lt;h4&gt;Passenger details&lt;/h4&gt;
                        &lt;/Col&gt;
                    &lt;/Row&gt;
                    &lt;Row className="show-grid"&gt;
                        &lt;Col xs={10} md={6}&gt;
                            &lt;ValidatedInput type='text'
                                label='FullName'
                                name='fullName'
                                errorHelp='FullName is invalid' /&gt;

                        &lt;/Col&gt;
                    &lt;/Row&gt;
                    &lt;Row className="show-grid"&gt;
                        &lt;Col xs={10} md={6}&gt;
                            &lt;ValidatedInput type='text'
                                label='Email'
                                name='email'
                                errorHelp='Email address is invalid' /&gt;
                        &lt;/Col&gt;
                    &lt;/Row&gt;
                    &lt;Row className="show-grid"&gt;
                        &lt;Col xs={10} md={6}&gt;
                            &lt;ValidatedInput type='password'
                                label='Password'
                                name='password'
                                errorHelp='Password is invalid' /&gt;
                        &lt;/Col&gt;
                    &lt;/Row&gt;
                    &lt;Row className="show-grid"&gt;
                        &lt;Col xs={10} md={6}&gt;
                            &lt;ButtonInput
                                id="registerBtn"
                                type='submit'
                                bsSize='small'
                                bsStyle='primary'
                                value='Register'&gt;Register&lt;/ButtonInput&gt;
                        &lt;/Col&gt;
                    &lt;/Row&gt;
                    &lt;Row className="show-grid"&gt;
                        &lt;span&gt;
                            &lt;OkDialog
                                open={this.state.okDialogOpen}
                                okCallBack={this.okDialogCallBack}
                                headerText={this.state.okDialogHeaderText}
                                bodyText={this.state.okDialogBodyText}
                                key={this.state.okDialogKey} /&gt;
                        &lt;/span&gt;
                    &lt;/Row&gt;
                &lt;/Grid&gt;
            &lt;/Form&gt;
        )
    }

    validateForm = (values) =&gt; {
        let res = revalidator.validate(values, schema);

        // If the values passed validation, we return true
        if (res.valid) {
            return true;
        }

        // Otherwise we should return an object containing errors
        // e.g. { email: true, password: true }
        return res.errors.reduce((errors, error) =&gt; {
            // Set each property to either true or
            // a string error description
            errors[error.property] = true;

            return errors;
        }, {});
    }

    handleInvalidSubmit = (errors, values) =&gt; {
        // Errors is an array containing input names
        // that failed to validate
        this.setState(
            {
                okDialogHeaderText: 'Validation Error',
                okDialogBodyText: 'Form has errors and may not be submitted',
                okDialogOpen: true,
                okDialogKey: Math.random()
            });
    }

    handleValidSubmit = (values) =&gt; {
        var passenger = values;
        var self = this;

        $.ajax({
            type: 'POST',
            url: 'registration/save/passenger',
            data: JSON.stringify(passenger),
            contentType: "application/json; charset=utf-8",
            dataType: 'json'
        })
        .done(function (jdata, textStatus, jqXHR) {
            var redactedPassenger = passenger;
            redactedPassenger.password = "";
            console.log("redacted ${redactedPassenger}");
            console.log(redactedPassenger);
            console.log("Auth Service");
            console.log(self.props.authService);
            let userProfile = {
                isDriver: false,
                user: redactedPassenger
            };
            self.setState(
                {
                    wasSuccessful: true,
                    okDialogHeaderText: 'Registration Successful',
                    okDialogBodyText: 'You are now registered',
                    okDialogOpen: true,
                    okDialogKey: Math.random()
                });
            self.props.authService.storeUser(userProfile);
        })
        .fail(function (jqXHR, textStatus, errorThrown) {
            self.setState(
                {
                    okDialogHeaderText: 'Error',
                    okDialogBodyText: jqXHR.responseText,
                    okDialogOpen: true,
                    okDialogKey: Math.random()
                });
        });
    }

    okDialogCallBack = () =&gt; {
        this.setState(
            {
                okDialogOpen: false
            });

        if (this.state.wasSuccessful) {
            hashHistory.push('/');
        }
    }
}
</pre>
<p>There are a couple of things of note there</p>
<ul>
<li>That we use a standard POST</li>
<li>That will post the registration data as JSON to the Play API backend code</li>
<li>That we also show a standard Boostrap OkDialog which we looked at last time, 
which when the Ok button is clicked will use the React Router to navigate to the 
route page</li>
	<li>That we use the
	<a href="https://www.npmjs.com/package/react-bootstrap-validation" target="_blank">
	react-bootstrap-validation</a> package for field validation</li>
	<li>That if the registration process is ok we store the user data in the
	<code>AuthorisationService.ts</code> that we saw earlier, where it in turn 
	writes to the browser <code>sessionStorage</code></li>
</ul>
<p>Let’s now turn our attention to the Play API backend code 
that goes with the “Passenger Registration”</p>
<h4>Json Support</h4>
<p>We need to start with the JSON suport from JavaScript to Scala. This is done 
using this file <code>PlayBackEndApi/app/Entities/PassengerRegistrationEntities.scala</code>, 
where we use Play framework JSON combinators</p>
<ul>
	<li><strong>Reads</strong> : Which allows reading a JSON string into a Scala 
	object</li>
	<li><strong>Writes</strong> : Which allows a Scala object to be turned into 
	a JSON string</li>
	<li><strong>Format</strong> : is just a mix of the Reads and Writes Traits 
	and can be used for implicit conversion in place of its components.</li>
</ul>
<p>The recommendation for both of these is that they are exposed as implicit 
vals you can read more about it here :
<a href="https://www.playframework.com/documentation/2.6.x/ScalaJsonCombinators" target="_blank">
https://www.playframework.com/documentation/2.6.x/ScalaJsonCombinators</a></p>
<pre lang="scala">
package entities

import play.api.libs.json._
import play.api.libs.functional.syntax._

case class PassengerRegistration(
  fullName: String,
  email: String,
  password: String)

object PassengerRegistration {
  implicit val formatter = Json.format[PassengerRegistration]
}

object PassengerRegistrationJsonFormatters {

  implicit val passengerRegistrationWrites = new Writes[PassengerRegistration] {
    def writes(passengerRegistration: PassengerRegistration) = Json.obj(
      "fullName" -&gt; passengerRegistration.fullName,
      "email" -&gt; passengerRegistration.email,
      "password" -&gt; passengerRegistration.password
    )
  }

  implicit val passengerRegistrationReads: Reads[PassengerRegistration] = (
    (JsPath \ "fullName").read[String] and
      (JsPath \ "email").read[String] and
      (JsPath \ "password").read[String]
    )(PassengerRegistration.apply _)
}</pre>
<h4>Registration route</h4>
<p>Once we have that in place we need to turn our attention to the actual 
endpoint to support the POST of a PassengerRegistration object. We first need to 
set up the route in the conf/routes file as follows:</p>
<pre>
# Registration page
POST  /registration/save/passenger             controllers.RegistrationController.savePassengerRegistration()
</pre>
<h4>Registration controller</h4>
<p>So now that we have talked about the JSON Reads/Writes and we know that we 
need Mongo downloaded and running (see how do I run this section at start), lets 
see what the actual controller looks like shall we. Here is the FULL code for 
the “Passenger Registration” portion of the <code>
PlayBackEndApi/app/controllers/RegistrationController.scala</code></p>
<pre lang="scala">
package controllers

import javax.inject.Inject
import play.api.mvc.{Action, Controller, Result}
import entities._
import entities.DriverRegistrationJsonFormatters._
import entities.PassengerRegistrationJsonFormatters._
import scala.concurrent.{ExecutionContext, Future}
import play.modules.reactivemongo._
import play.api.Logger
import utils.Errors
import play.api.libs.json._
import reactivemongo.api.ReadPreference
import reactivemongo.play.json._
import collection._

class RegistrationController @Inject()
  (val reactiveMongoApi: ReactiveMongoApi)
  (implicit ec: ExecutionContext)
  extends Controller with MongoController with ReactiveMongoComponents {

  def passRegistrationFuture: Future[JSONCollection] = database.map(_.collection[JSONCollection]("passenger-registrations"))
  def driverRegistrationFuture: Future[JSONCollection] = database.map(_.collection[JSONCollection]("driver-registrations"))


  def savePassengerRegistration = Action.async(parse.json) { request =&gt;
    Json.fromJson[PassengerRegistration](request.body) match {
      case JsSuccess(newPassRegistration, _) =&gt;

        //https://github.com/ReactiveMongo/ReactiveMongo-Extensions/blob/0.10.x/guide/dsl.md
        val query = Json.obj("email" -&gt; Json.obj("$eq" -&gt; newPassRegistration.email))

        dealWithRegistration[PassengerRegistration](
          newPassRegistration,
          passRegistrationFuture,
          query,
          PassengerRegistration.formatter)
      case JsError(errors) =&gt;
        Future.successful(BadRequest("Could not build a PassengerRegistration from the json provided. " +
          Errors.show(errors)))
    }
  }

  private def dealWithRegistration[T](
          incomingRegistration: T,
          jsonCollectionFuture: Future[JSONCollection],
          query: JsObject,
          formatter: OFormat[T])
          (implicit ec: ExecutionContext): Future[Result] = {

    def hasExistingRegistrationFuture = jsonCollectionFuture.flatMap {
        //http://reactivemongo.org/releases/0.11/documentation/advanced-topics/collection-api.html
        _.find(query)
        .cursor[JsObject](ReadPreference.primary)
        .collect[List]()
      }.map(_.length match {
          case 0 =&gt; false
          case _ =&gt; true
      }
    )

    hasExistingRegistrationFuture.flatMap {
      case false =&gt; {
        for {
          registrations &lt;- jsonCollectionFuture
          writeResult &lt;- registrations.insert(incomingRegistration)(formatter,ec)
        } yield {
          Logger.debug(s"Successfully inserted with LastError: $writeResult")
          Ok(Json.obj())
        }
      }
      case true =&gt; Future(BadRequest("Registration already exists"))
    }
  }
}
</pre>
<p>Lets break this down into chunks</p>
<ul>
	<li>The controller constructor<ul>
		<li>This takes a <code>ReactiveMongoApi </code>(this is mandatory to 
		satisfy the base trait <code>MongoController </code>requirements)</li>
		<li>Inherits from <code>MongoController </code>which provides a lot of 
		use functionality</li>
		<li>It also inherits from <code>ReactiveMongoComponents </code>in order 
		to allow the cake pattern/self typing requirements of the base <code>
		MongoController </code>which expects a <code>ReactiveMongoComponents</code></li>
	</ul>
	</li>
	<li>The use of <code>JSONCollection</code><ul>
		<li>There is a <code>Future[JSONCollection]</code> that represents the 
		passenger collection in Mongo. This is a collection that stores JSON. 
		When using reactive Mongo you have a choice about whether to use the 
		standard BSON collections of JSON. I opted for JSON</li>
	</ul>
	</li>
	<li>The Guts Of The Logic<ul>
		<li>So now we have discussed the controller constructor and the Mongo 
		collections. We just need to talk about the actual work that happens on 
		registration. In a nutshell it works like this<ul>
			<li>The incoming JSON string is turned into a <code>
			PassengerRegistration </code>object via Play</li>
			<li>We then create a new JSON query object to query the Mongo <code>
			JSONCollection </code>to see if a registration already exists</li>
			<li>If a registration already exists we exit with a <code>BadRequest
			</code>output</li>
			<li>If a registration does NOT already exist we insert the new 
			registration details into the Mongo <code>JSONCollection </code>, 
			and the we return an <code>Ok </code>output</li>
		</ul>
		</li>
	</ul>
	</li>
</ul>
<p>And that is how the “Passenger Registration” works.</p>
<p>&nbsp;</p>
<h3><strong>Driver registration</strong></h3>
<p>The driver registration works in much the same way as described above, its 
just slightly different JSON, but it does share the same core logic/controller 
as the “Passenger Registration”</p>
<p>&nbsp;</p>
<h2>Login workflow</h2>
<p><img alt="" height="217" src="loginRegisterFlow.png" width="630"></p>
<p>The login uses the 
pieces shown above.</p>
<div>
<p style="background:yellow; margin:3px; border:1px black solid">This workflow 
is VERY similiar to registration, so feel free to skip this section if you think 
you understand how registation concepts work</p>
</div>
<h3>How does Webpack/Play work with this?</h3>
<p>WebPack has this concept of loaders that are what gets used to load different 
file types. So for example you can use a TypeScr</p>
<p>&nbsp;</p>
<h4>Login React component</h4>
<p>This is the main <code>
PlayBackEndApi/FrontEndWebSite/src/Login.tsx</code> file for the React TSX representing the 
login component.</p>
<pre lang="js">
import * as React from "react";
import * as ReactDOM from "react-dom";
import { OkDialog } from "./components/OkDialog";
import 'bootstrap/dist/css/bootstrap.css';
import {
    Well,
    Grid,
    Row,
    Col,
    ButtonInput
} from "react-bootstrap";
import { Form, ValidatedInput } from 'react-bootstrap-validation';
import revalidator from 'revalidator';
import { AuthService } from "./services/AuthService";

let schema = {
    properties: {
        email: {
            type: 'string',
            maxLength: 255,
            format: 'email',
            required: true,
            allowEmpty: false
        },
        password: {
            type: 'string',
            minLength: 8,
            maxLength: 60,
            required: true,
            allowEmpty: false
        }
    }
};

export interface LoginState {
    okDialogOpen: boolean;
    okDialogKey: number;
    okDialogHeaderText: string;
    okDialogBodyText: string;
}

export class Login extends React.Component&lt;undefined, LoginState&gt; {

    private _authService: AuthService;

    constructor(props: any) {
        super(props);
        console.log(props);
        this._authService = props.route.authService;
        this.state = {
            okDialogHeaderText: '',
            okDialogBodyText: '',
            okDialogOpen: false,
            okDialogKey: 0
        };
    }

    render() {
        return (
            &lt;Well className="outer-well"&gt;
                &lt;Form
                    // Supply callbacks to both valid and invalid
                    // submit attempts
                    validateAll={this.validateForm}
                    onInvalidSubmit={this.handleInvalidSubmit}
                    onValidSubmit={this.handleValidSubmit}&gt;
                    &lt;Grid&gt;
                        &lt;Row className="show-grid"&gt;
                            &lt;Col xs={10} md={6}&gt;
                                &lt;h4&gt;ENTER YOUR LOGIN DETAILS&lt;/h4&gt;
                                &lt;span&gt;&lt;h6&gt;Or click &lt;a href="#/register"&gt;here&lt;/a&gt; to register&lt;/h6&gt;&lt;/span&gt;
                            &lt;/Col&gt;
                        &lt;/Row&gt;
                        &lt;Row className="show-grid"&gt;
                            &lt;Col xs={10} md={6}&gt;
                                &lt;ValidatedInput type='text'
                                    label='Email'
                                    name='email'
                                    errorHelp='Email address is invalid' /&gt;

                            &lt;/Col&gt;
                        &lt;/Row&gt;
                        &lt;Row className="show-grid"&gt;
                            &lt;Col xs={10} md={6}&gt;
                                &lt;ValidatedInput type='password'
                                    name='password'
                                    label='Password'
                                    errorHelp='Password is invalid' /&gt;

                            &lt;/Col&gt;
                        &lt;/Row&gt;
                        &lt;Row className="show-grid"&gt;
                            &lt;Col xs={10} md={6}&gt;
                                &lt;ValidatedInput
                                    type='checkbox'
                                    name='isDriver'
                                    label='Are you a driver?'
                                /&gt;
                            &lt;/Col&gt;
                        &lt;/Row&gt;
                        &lt;Row className="show-grid"&gt;
                            &lt;Col xs={10} md={6}&gt;
                                &lt;ButtonInput
                                    id="loginBtn"
                                    type='submit'
                                    bsSize='small'
                                    bsStyle='primary'
                                    value='Register'&gt;Login&lt;/ButtonInput&gt;
                            &lt;/Col&gt;
                        &lt;/Row&gt;
                        &lt;Row className="show-grid"&gt;
                            &lt;span&gt;
                                &lt;OkDialog
                                    open={this.state.okDialogOpen}
                                    okCallBack={this.okDialogCallBack}
                                    headerText={this.state.okDialogHeaderText}
                                    bodyText={this.state.okDialogBodyText}
                                    key={this.state.okDialogKey} /&gt;
                            &lt;/span&gt;
                        &lt;/Row&gt;
                    &lt;/Grid&gt;
                &lt;/Form&gt;
            &lt;/Well&gt;
        )
    }

    validateForm = (values) =&gt; {
        let res = revalidator.validate(values, schema);

        // If the values passed validation, we return true
        if (res.valid) {
            return true;
        }

        // Otherwise we should return an object containing errors
        // e.g. { email: true, password: true }
        return res.errors.reduce((errors, error) =&gt; {
            // Set each property to either true or
            // a string error description
            errors[error.property] = true;

            return errors;
        }, {});
    }

    handleInvalidSubmit = (errors, values) =&gt; {

        console.log(values);

        // Errors is an array containing input names
        // that failed to validate
        this.setState(
            {
                okDialogHeaderText: 'Validation Error',
                okDialogBodyText: 'Form has errors and may not be submitted',
                okDialogOpen: true,
                okDialogKey: Math.random()
            });
    }

    handleValidSubmit = (values) =&gt; {
        var logindetails = values;
        var self = this;

        $.ajax({
            type: 'POST',
            url: 'login/validate',
            data: JSON.stringify(logindetails),
            contentType: "application/json; charset=utf-8",
            dataType: 'json'
        })
        .done(function (jdata, textStatus, jqXHR) {

            console.log("result of login");
            console.log(jqXHR.responseText);
            let currentUser = JSON.parse(jqXHR.responseText);
            let userProfile = {
                isDriver: logindetails.isDriver,
                user: currentUser
            };
            self._authService.storeUser(userProfile);

            self.setState(
                {
                    okDialogHeaderText: 'Login Successful',
                    okDialogBodyText: 'You are now logged in',
                    okDialogOpen: true,
                    okDialogKey: Math.random()
                });
        })
        .fail(function (jqXHR, textStatus, errorThrown) {
            self.setState(
                {
                    okDialogHeaderText: 'Error',
                    okDialogBodyText: jqXHR.responseText,
                    okDialogOpen: true,
                    okDialogKey: Math.random()
                });
        });
    }

    okDialogCallBack = () =&gt; {
        this.setState(
            {
                okDialogOpen: false
            });
    }
}
</pre>
<p>There are a couple of things of note there</p>
<ul>
<li>That we use a standard POST</li>
<li>That will post the login data as JSON to the Play API backend code</li>
	<li>That we use the
	<a href="https://www.npmjs.com/package/react-bootstrap-validation" target="_blank">
	react-bootstrap-validation</a> package for field validation</li>
	<li>That if the login process is ok we store the user data in the
	<code>AuthorisationService.ts</code> that we saw earlier, where it in turn 
	writes to the browser <code>sessionStorage</code></li>
</ul>
<p>Let’s now turn our attention to the Play API backend code 
that goes with the “Login”</p>
<h4>Json Support</h4>
<p>We need to start with the JSON suport from JavaScript to Scala. This is done 
using this file <code>PlayBackEndApi/app/Entities/LoginEntities.scala</code>, 
where we use Play framework JSON combinators</p>
<ul>
	<li><strong>Reads</strong> : Which allows reading a JSON string into a Scala 
	object</li>
	<li><strong>Writes</strong> : Which allows a Scala object to be turned into 
	a JSON string</li>
	<li><strong>Format</strong> : is just a mix of the Reads and Writes Traits 
	and can be used for implicit conversion in place of its components.</li>
</ul>
<p>The recommendation for both of these is that they are exposed as implicit 
vals you can read more about it here :
<a href="https://www.playframework.com/documentation/2.6.x/ScalaJsonCombinators" target="_blank">
https://www.playframework.com/documentation/2.6.x/ScalaJsonCombinators</a></p>
<pre lang="scala">
package entities

import play.api.libs.json._
import play.api.libs.functional.syntax._

case class Login(email: String, password: String, isDriver: Boolean)

object Login {
  implicit val formatter = Json.format[Login]
}

object LoginJsonFormatters {

  implicit val loginWrites = new Writes[Login] {
    def writes(login: Login) = Json.obj(
      "email" -&gt; login.email,
      "password" -&gt; login.password,
      "isDriver" -&gt; login.isDriver
    )
  }

  implicit val loginReads: Reads[Login] = (
      (JsPath \ "email").read[String] and
      (JsPath \ "password").read[String] and
      ((JsPath \ "isDriver").read[Boolean])
    )(Login.apply _)
}
</pre>
<h4>Login route</h4>
<p>Once we have that in place we need to turn our attention to the actual 
endpoint to support the POST of a Login object. We first need to 
set up the route in the conf/routes file as follows:</p>
<pre>
# Login page
POST  /login/validate                          controllers.LoginController.validateLogin()
</pre>
<h4>Login controller</h4>
<p>So now that we have talked about the JSON Reads/Writes and we know that we 
need Mongo downloaded and running (see how do I run this section at start), lets 
see what the actual controller looks like shall we. Here is the FULL code for 
the <code>
PlayBackEndApi/app/controllers/LoginController.scala</code></p>
<pre lang="scala">
package controllers

import javax.inject.Inject
import entities.DriverRegistrationJsonFormatters._
import entities.PassengerRegistrationJsonFormatters._
import entities._
import play.api.Logger
import play.api.libs.json._
import play.api.mvc.{Action, Controller, Result}
import play.modules.reactivemongo._
import reactivemongo.api.ReadPreference
import reactivemongo.play.json._
import reactivemongo.play.json.collection._
import utils.Errors


import scala.concurrent.{ExecutionContext, Future}

class LoginController @Inject()
  (val reactiveMongoApi: ReactiveMongoApi)
  (implicit ec: ExecutionContext)
  extends Controller with MongoController with ReactiveMongoComponents {

  def passRegistrationFuture: Future[JSONCollection] = database.map(_.collection[JSONCollection]("passenger-registrations"))
  def driverRegistrationFuture: Future[JSONCollection] = database.map(_.collection[JSONCollection]("driver-registrations"))


  def validateLogin = Action.async(parse.json) { request =&gt;
    Json.fromJson[Login](request.body) match {
      case JsSuccess(newLoginDetails, _) =&gt;
        newLoginDetails.isDriver match {
          case false =&gt; {
            val maybePassengerReg = extractExistingRegistration(
              passRegistrationFuture.flatMap {
                _.find(Json.obj("email" -&gt; Json.obj("$eq" -&gt; newLoginDetails.email))).
                  cursor[JsObject](ReadPreference.primary).
                  collect[List]()
              })
            returnRedactedRegistration[PassengerRegistration](
              maybePassengerReg,
              (reg: PassengerRegistration) =&gt; Ok(Json.toJson(reg.copy(password = "")))
            )

          }
          case true =&gt; {
            val maybeDriverReg = extractExistingRegistration(
              driverRegistrationFuture.flatMap {
                _.find(Json.obj("email" -&gt; Json.obj("$eq" -&gt; newLoginDetails.email))).
                  cursor[JsObject](ReadPreference.primary).
                  collect[List]()
              })
            returnRedactedRegistration[DriverRegistration](
              maybeDriverReg,
              (reg: DriverRegistration) =&gt; Ok(Json.toJson(reg.copy(password = "")))
            )
          }
        }
      case JsError(errors) =&gt;
        Future.successful(BadRequest("Could not build a Login from the json provided. " +
          Errors.show(errors)))
    }
  }

  private def returnRedactedRegistration[T]
  (
    maybeDriverRegFuture: Future[Option[JsObject]],
    redactor : T =&gt; Result
  )(implicit reads: Reads[T]): Future[Result] = {
    maybeDriverRegFuture.map {
      case Some(json) =&gt; {
        val reg = Json.fromJson[T](json)
        reg match {
          case JsSuccess(reg, _) =&gt; {
            redactor(reg)
          }
          case _ =&gt; BadRequest("Login already exists")
        }
      }
      case None =&gt; BadRequest("Could not find login")
    }
  }

  private def extractExistingRegistration[T]
  (incomingRegistrations: Future[List[T]])
  (implicit writes: Writes[T], ec: ExecutionContext): Future[Option[T]] = {
    incomingRegistrations.map(matchedRegistrations =&gt;
      matchedRegistrations.length match {
        case 0 =&gt; None
        case _ =&gt; Some(matchedRegistrations(0))
      }
    )
  }
}
</pre>
<p>This is similiar enough in nature to the registration process, so I will not 
go into this any further.</p>
<h2>CreateJob workflow</h2>
<p class="auto-style1">NEED TO DO THIS</p>
<h2>&nbsp;</h2>
<h2>ViewJob workflow</h2>
<p class="auto-style1">NEED TO DO THIS</p>
<h2>&nbsp;</h2>
<h2>ViewRating workflow</h2>
<p class="auto-style1">NEED TO DO THIS</p>
<h2>&nbsp;</h2>
<h1>Conclusion</h1>
<p>This was certainly a challenging thing to write, and I am honestly pleased that I got it done, I have had a really good time writing this. And it has been a great project for self improvement, and 
I would recommend this type of thing as a great use of time. Go on find yourself 
a pet project</p>



